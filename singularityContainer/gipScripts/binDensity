#samplesList="samplesList"
#gipOut="gipOut"
#outName=NA
#chrs=NA
#debug=FALSE
#pseudocount=0.1
#minMAPQ=50
#highLowCovThresh=c(1.5,0.5)
#showSubset=50000
#bandwidth=c(0.1 , 0.05)
#nbin=400

suppressPackageStartupMessages(library("argparse"))
parser <- ArgumentParser(description="Density plot of bin sequencing coverage of many samples")
parser$add_argument("--samplesList" , nargs="+", help="File listing in one column the samples to use. If \"NA\" all samples are used" , default="NA" )
parser$add_argument("--gipOut"  , help="GIP output directory. If \"NA\" the directory \"./gipOut\" is used" , default="NA")
parser$add_argument("--outName" , help="Output name [default %(default)s]" , default="NA")
parser$add_argument("--chrs"    , nargs="+" , help="Chromosomes to use. If \"NA\" it uses the same chromsomes as GIP [default %(default)s]" , default="NA")
parser$add_argument("--minMAPQ" , type="integer"   , help="Remove bins with MAPQ < --minMAPQ [default %(default)s]", default=0 )
parser$add_argument("--pseudocount" , type="double" , help="Normalized mean coverage pseudocount value preventing minus infinite values in log10 transformation [default %(default)s]" , default=0.1)
parser$add_argument("--highLowCovThresh" , nargs="+" , type="double" , help="Provide two numbers. Bins with normalized coverage values > num1 or < num2 will be labeled. [default %(default)s]" , default= c(1.5,0.5) )
parser$add_argument("--bandwidth" , type="double" , nargs="+" , help="Smoothing bandwidth value. Provide two numbers to enforce different bandwidths on the x and y axes respectively [default %(default)s]" , default=c(10000  , 0.01))
parser$add_argument("--nbin" , type="integer" ,  nargs="+" , help="Number of equally spaced grid points for the density estimation. Provide two numbers to use different numbers for the x and y axes respectively [default %(default)s]" , default=1000)
parser$add_argument("--showSubset" , type="integer" , help="Show a random subset of genomic bins with normalized coverage values above or below --highLowCovThresh. This random subset does not affect the density estimation [default %(default)s]", default=50000)
parser$add_argument("--debug"  , action="store_true" , help="Dump session and quit [default %(default)s]" , default=FALSE)
args <- parser$parse_args()

#patch NA
for (n in names(args)){if(args[[n]][1] == "NA"){args[[n]] <- NA}  }
for (n in names(args)){assign(n,args[[n]]) }

suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(fields))
suppressPackageStartupMessages(library("openxlsx"))
suppressPackageStartupMessages(library("session"))
options(datatable.fread.input.cmd.message=FALSE)
if(debug){library(session);save.session("session_DEBUG_binDensity");quit()}

#setup
if (is.na(gipOut)){
  gipOut <- "./gipOut"
}
if(! dir.exists(gipOut)){
  stop("ERROR. gipOut directory does not exists")
  quit(save = "no", status = 1, runLast = FALSE)
}
outDir <- paste0(gipOut,"/sampleComparison/")
system(paste0("mkdir -p ", outDir))
if (is.na(outName)){
  outName <- paste0(outDir,"binDensity")
}
if (is.na(samplesList[1])) {
  samples <- dir(paste0(gipOut,"/samples"))
}  else{ 
  samples <- read.table(samplesList,stringsAsFactors=F)$V1
}
chrSel      <- as.character(read.table(paste0(gipOut,"/samples/",samples[1],"/chrCoverageMedians_",samples[1]),header=T)[,1])
chrSize     <- read.table(paste0(gipOut,"/genome/genome.chrSize"),sep="\t", stringsAsFactors = F, header=F , col.names=c("chr","size"))
chrSize$chr <- as.character(chrSize$chr)
chrSize     <- chrSize[match(chrSel,chrSize$chr),]
if (is.na (chrs[1])){
  chrs <- chrSize$chr
}
chrSize <- chrSize[chrSize$chr %in% chrs,]

#chr size cumulative sum
chrSizeCumSum <- cumsum(chrSize$size)
v <- c(0,chrSizeCumSum)
chrSizeCumSum <- v[-length(v)]
names(chrSizeCumSum) <- chrSize$chr

#chr mid points
chrMids <- c()
for (i in 1:length(chrSizeCumSum)-1) {chrMids = c(chrMids , (chrSizeCumSum[i] + chrSizeCumSum[i + 1]) / 2)}
chrMids =c(chrMids ,  ( chrSizeCumSum[length(chrSizeCumSum)] + sum(chrSize$size) ) / 2)

#read covPerBin
covPerBinList <- list()
for (s in samples){
  covPerBinList[[s]] <- fread(cmd=paste0("gunzip -c ", gipOut , "/samples/" , s , "/" , s , ".covPerBin.gz"  ), select=c("chromosome","start","normalizedMeanCoverage","MAPQ"))
  positionCorrection <- chrSizeCumSum[match(covPerBinList[[s]]$chromosome, names(chrSizeCumSum))]
  covPerBinList[[s]]$startFixed <- covPerBinList[[s]]$start + positionCorrection
  covPerBinList[[s]]$sample <- s
}
covPerBinDf <- do.call(rbind,covPerBinList)
df <- covPerBinDf[with(covPerBinDf, order(startFixed)), ]

#filter
df <- df[ df$normalizedMeanCoverage <= 0.01 | (df$normalizedMeanCoverage > 0.01 & df$MAPQ > minMAPQ) ,]
df <- as.data.frame(df)

#add pseudocount just to deletions
df$normalizedMeanCoverage[df$normalizedMeanCoverage <= pseudocount ] = pseudocount

#materializedPoints
materializedPoints <- df[df$normalizedMeanCoverage <= highLowCovThresh[2] | df$normalizedMeanCoverage >= highLowCovThresh[1],]
materializedPoints<- unique(materializedPoints)
maxPointsNum <- min(length(materializedPoints[,1]) , showSubset)
set.seed(321)
materializedPoints <- materializedPoints[sample(nrow(materializedPoints), maxPointsNum), ]

#legend for smoothScatter
fudgeit <- function(){
  xm <- get('xm', envir = parent.frame(1))
  ym <- get('ym', envir = parent.frame(1))
  z  <- get('dens', envir = parent.frame(1))
  colramp <- get('colramp', parent.frame(1))
  fields::image.plot(xm,ym,z, col = colramp(256), legend.only = T, add =F)# , horizontal=T)
}

#plot smooth
pdf(paste0(outName,".pdf"),width=18, height=10)
par(font.axis = 2 , mar = c(5,4,4,5) + .1)
smoothScatter(x=df$startFixed , y=log10(df$normalizedMeanCoverage) , bandwidth=bandwidth , nbin=nbin , nrpoints=0 , xlab="" , ylab="",xaxt = 'n' , postPlotHook = fudgeit , xaxs="i" , yaxs="i" , font=2)
points(materializedPoints$startFixed, log10(materializedPoints$normalizedMeanCoverage), pch=19, col="black", cex=0.2)
segments(x0=0 , y0=log10(highLowCovThresh[1]) , x1=sum(chrSize$size) , y1=log10(highLowCovThresh[1]) , lty=3, col='red', lwd=1)
segments(x0=0 , y0=0 , x1=sum(chrSize$size) , y1=0 , lty=2, col='black', lwd=1)
segments(x0=0 , y0=log10(highLowCovThresh[2]) , x1=sum(chrSize$size) , y1=log10(highLowCovThresh[2]) , lty=3, col='red', lwd=1)
abline(v=chrSizeCumSum[-1], lty=1, col='gray', lwd=2)
axis(1, at=chrMids, labels=names(chrMids) , font=2 , las=2)
mtext(side=2, line=3, "Log10 normalized bin coverage", , font=2, cex=1.2)
invisible(dev.off())


