#filter a vcf file generated by delly version 0.6.7 (VCF format 4.1) run on multiple samples (bam) together (so you will have one genotype per sample)
#the idea is to select the structural variants (SV, selected by --SVTYPE) present in the test sample (--test) but not in the reference sample (--reference)
#SV with respect to the reference assembly that shared by both test and reference samples are not the interest of this script. 
#set --minDVtest to the minimum amount of reads supporting the SV in the test sample (e.g. 10) and --maxDVreference to the max amount of reads supporting the SV in the reference sample (set it to zero if you wanna select just the very clean SV).
#you can also filter by minFractionDVDRtest and maxFractionDVDRreference, but the fraction does not tell you about the absolute support of the SV, so for instance a SV supported just by one read in the test sample, by zero reads in the reference sample would still be accepted (unless minDVtest is also used)

#see https://groups.google.com/forum/#!topic/delly-users/6Mq2juBraRY
#DR & DV represent counts for reference and SV supporting paired-ends, which are then fed into the genotyping model to derive genotype likelihoods, a genotype quality and the final genotype call. For precise events (INFO:PRECISE), Delly uses RR & RV, which are the reference and SV allele supporting reads (not pairs) because the exact breakpoint sequence is known. The sum of all DV counts (across all input samples) should be close to INFO:PE because for the SV discovery Delly pools all paired-ends from all samples. The numbers are not identical because the SV discovery stops searching for additional support once enough confident abnormal paired-ends have been found (to save runtime) and likewise the genotyping is a bit more strict for quality (20 by default) and insert size

#Output the filtered vcf, and the bed version of it to ease downstream bedtools comparisons. the command line to pass from vcf to bed were found here https://groups.google.com/forum/#!topic/delly-users/X60sAgigQ5g
#The transclocations are particular cases, and for them a 10nt window is included

#You may be interested in comparing your test sample not against a reference sample but simply against the assembly. In this case you can still use this script by assigning to --test and --reference the same sample name, and then remove the filters that are dedicated to the the reference sample (e.g. by assigning maxFractionDVDRreference and maxDVreference to 99999) 

#NOTE! As Jen pointed in one email (see gmail 16/01/2017) sometimes the VCF files aren't adequate for the package VariantAnnotation to well determine the variant end point. A genuine vcf file should have in the ALT and REF fields the bases or the length of the variation. e.g.:
#chr1    599481  .       AT      A       .       PASS    INFO_COLUMN
#In practice delly just puts the name of the structural variant (e.g. <DEL>). So VariantAnnotation does not know the length of the structural variations. You have to use the END column in info(vcf) to have the real variant end. This is not the default of VariantAnnotation because you cannot rely always on the END field. For instance freebayes does not use it. Because of this reason you need to check the ALT REF and END fields of the vcf file and then specify --useENDfield [yes|no] accordingly. For delly version 0.6.7 this should be set to yes. This is unless the variant type is a traslocation (TRA). In this case you need to set it to "no" because the end point is used to compute the variant length, and if it is a traslocation thiss does not make any sense and can even be negative. For freebayes v1.0.1-2-g0cb2697 you should put "no" because the END field is "NA" while the ALT field is good. 

#Example: Rscript filterDelly.R --useENDfield yes --vcfFile DEL.vcf --SVTYPE DEL --test hamster_immunoCompetent_H154p2spleen --reference hamster_immunoCompromised_cycloSpleen --minPE 50 --minPercentDVDRtest 20 --maxPercentDVDRreference 1 --PRECISE no --outName hamster_immunoCompetent_H154p2spleen__hamster_immunoCompromised_cycloSpleen__SV --minDVtest 10 --maxDVreference 0 --minFractionDVDRtest 0.1 --minMAPQ 50  --maxFractionDVDRreference 0 
#################################################
#		CONFIGURATION
#################################################
suppressPackageStartupMessages(library("argparse"))
# create parser object
parser <- ArgumentParser()
# specify our desired options # by default ArgumentParser will add an help option
parser$add_argument("--vcfFile" , nargs="+", help="vcf file  [default %(default)s]" )
parser$add_argument("--test"      , help="test condition name in the vcf file [default %(default)s]")
parser$add_argument("--reference" , help="reference condition name in the vcf file [default %(default)s]")
parser$add_argument("--SVTYPE" , help="SV type, e.g. DEL, DUP, INV, TRA [default %(default)s]")
parser$add_argument("--minMAPQ" , type="integer" , help="min Median mapping quality of paired-ends supporting the SV [default %(default)s]" , default="40")
parser$add_argument("--minPE" , type="integer" , help="min paired-end support of the structural variant summing up all conditions [default %(default)s]" , default="10")
parser$add_argument("--minDVtest" , type="integer" , help="min paired-end support of the structural variant in the test sample [default %(default)s]" , default="20")
parser$add_argument("--maxDVreference" , type="integer" , help="max paired-end support of the structural variant in the reference sample [default %(default)s]" , default="0")
parser$add_argument("--minPercentDVDRtest",type="double", help="min (DV/(DV+DR))*100 in the test sample (i.e. min percent of reads supporting the structural variant in the test sample)  [default %(default)s]" , default="20")
parser$add_argument("--maxPercentDVDRreference",type="double", help="max (DV/(DV+DR))*100 in the reference sample (i.e. max percent of reads supporting the structural variant in the reference sample)  [default %(default)s]" , default="0")
parser$add_argument("--PRECISE" , help="select just the structural variants labelled as PRECISE [default %(default)s]", default="no")
parser$add_argument("--outName" , help="output name [default %(default)s]", default="_outFilterDelly")
parser$add_argument("--chrSizeFile" , help="chr size file [default %(default)s]", default="NA")
parser$add_argument("--badSequencesBed"  , help="bed3 file including intervals of bad sequences (e.g. gaps or repeats). SVs embedding too many (see --maxBadSeqPercent) of those will be filtered [default %(default)s]", default="NA")
parser$add_argument("--maxBadSeqPercent" , type="integer" , help="filter SVs with a percent of bad sequences (see --badSequencesBed) is > maxBadSeqPercent  [default %(default)s]", default="101")
parser$add_argument("--filterSVatTheTelomericEnds" , type="integer", help="number of bases from the chr ends to consider when filtering SV overlapping the telomers. Depends on --chrSizeFile  [default %(default)s]", default="1000")
parser$add_argument("--useENDfield" , help="VariantAnnotation uses the info(vcf) END field to define the variant end [yes|no]. Recommended if you process delly vcf files unless it is a traslocation (TRA)  [default %(default)s]" )
parser$add_argument("--chrsToKeep" , nargs="+", help="if specified, filter out all the SVs laying on chrs not in this list  [default %(default)s]" , default="NA" )

args <- parser$parse_args()
#patch NA
for (n in names(args)){if(args[[n]][1] == "NA"){args[[n]] <- NA}  }
for (n in names(args)){assign(n,args[[n]]) }

#library(session)
#save.session("session")
#quit()

#read
library("VariantAnnotation")
vcf = readVcf(vcfFile, 'genome')
#select just the sv of interest 
vcf <- vcf[ info(vcf)$SVTYPE == SVTYPE, ]
#patch vcf end position using the END field
if(useENDfield == "yes") {
        end(vcf) = info(vcf)$END
}
#remove lowQual
vcf =vcf[rowRanges(vcf)$FILTER == "PASS",]
#remove SV not supported by many reads
vcf =vcf[info(vcf)$PE > minPE,]
#remove SV whose the median MAPQ is too low (e.g. the reads align to repeats)
vcf =vcf[info(vcf)$MAPQ > minMAPQ,]
#remove imprecise SV
if(PRECISE == "yes"){vcf <- vcf[info(vcf)$PRECISE, ]}
#remove SV overlapping the chr ends
if(!is.na(chrSizeFile)){
	chrSizes       <- read.table(chrSizeFile,header=F,stringsAsFactors=F)
	chrSizes$start <- 1
	names(chrSizes)<- c("chr","end","start")
	chrBegins <- data.frame(chr=chrSizes$chr, start=chrSizes$start , end=filterSVatTheTelomericEnds)
	chrEnds   <- data.frame(chr=chrSizes$chr, start=chrSizes$end - filterSVatTheTelomericEnds , end=chrSizes$end)
	chrExtremities <- rbind(chrBegins,chrEnds)
	chrExtremitiesGr <- with(chrExtremities, GRanges(chr, IRanges(start, end)))
	ov  <- findOverlaps(vcf,chrExtremitiesGr)
	if (length(queryHits(ov)) > 0 ){
		vcf <- vcf[-queryHits(ov)]
	}
}
#remove SVs on unwanted chrs
if(!is.na(chrsToKeep[1])){
	vcf <- vcf[seqnames(vcf) %in% chrsToKeep , ]
	if ("CHR2" %in% names(info(vcf))){
		vcf <- vcf[info(vcf)$CHR2 %in% chrsToKeep , ]
	}
}

#remove SVs embedding many unwanted sequences (e.g. gaps, repeats)
if(!is.na(badSequencesBed) && length(rowRanges(vcf)) > 0 ){  
	badSequencesIntervals <- read.table(badSequencesBed,header=F,stringsAsFactors=F)
	names(badSequencesIntervals) <- c("chr","start","end")
	badSequencesGr <- with(badSequencesIntervals, GRanges(chr, IRanges(start, end)))
	badSequencesGr <- reduce(badSequencesGr)
	allPercOvBad<-c(); 
	for (i in 1:length(rowRanges(vcf))){ 
		queryGr    = rowRanges(vcf[i,])
		ovBases    = sum(width(intersect(queryGr,badSequencesGr)))
		queryBases = width(queryGr)
		percOvBad  = round((ovBases/queryBases)*100,digit=0)
		allPercOvBad <- c(allPercOvBad,percOvBad)  
	}
	vcf <- vcf[allPercOvBad < maxBadSeqPercent,]
}

#quit if no variant survived the filters
if (length(vcf) == 0){
        print("no SV passed all the filters")
	system(paste0("echo > ",outName,".bed") )
	system(paste0("echo > ",outName,".vcf") )
        quit(save = "no", status = 0, runLast = FALSE)  
}

#fraction of pair-reads supporting the variant for each sample
geno(vcf)[["DVDRpercent"]] =  round(geno(vcf)[["DV"]] / (geno(vcf)[["DR"]] + geno(vcf)[["DV"]]) , digit=2) * 100;
goodDVDRselector <- geno(vcf)[["DV"]][,test] >= minDVtest & geno(vcf)[["DV"]][,reference] <= maxDVreference &  geno(vcf)[["DVDRpercent"]][,test] >= minPercentDVDRtest & geno(vcf)[["DVDRpercent"]][,reference] <= maxPercentDVDRreference
goodDVDRselector[is.na(goodDVDRselector)]=FALSE
vcf = vcf[goodDVDRselector,]

#print out
writeVcf(vcf,filename=paste(outName,".vcf",sep=""))
if ((SVTYPE == "DEL") || (SVTYPE == "DUP") || (SVTYPE == "INV")){
	bed <- data.frame(chr=seqnames(vcf) , start=start(vcf) , end=end(vcf) , name=names(vcf) , percentVariantSupport=geno(vcf)[["DVDRpercent"]] , stringsAsFactors=F)
	write.table(x=bed,quote=F,append=F,col.names=F,row.names=F,sep="\t",file=paste0(outName,".bed"))
} else if (SVTYPE == "TRA") {
	bed<-NULL; 
	for (n in names(vcf)) {
		chr = seqnames(vcf[n,])
		start = start(vcf[n,]) - 10
		end = start + 20
		perc = geno(vcf[n,])[["DVDRpercent"]] 
		chr2 = info(vcf[n,])$CHR2 
		start2 = info(vcf[n,])$END - 10 
		end2 = start2  + 20 
		row1=paste(chr,start,end,n,perc)
		row2=paste(chr2,start2,end2,n,perc)
		rbind(bed,row1,row2) -> bed      
	}
	write.table(x=bed,quote=F,append=F,col.names=F,row.names=F,sep="\t",file=paste0(outName,".bed"))
	system( paste0('sed -i \'s/ /\t/g\' ' , outName,'.bed') )    
}



#system( paste( 'cat ',outName,'.vcf | grep -v "^#" | cut -f 1,2,3,8 | sed \'s/\t[^\t]*;END=/\t/\' | sed \'s/;.*$//\' | awk \'{print $1"\t"$2"\t"$4"\t"$3;}\' > ',outName,'.bed'  ,sep="")  )
#system( paste( 'cat ',outName,'.vcf | grep -v "^#" | cut -f 1,2,3,8 | sed \'s/\t[^\t]*;CHR2=/\t/\' | sed \'s/;END=/\t/\' | sed \'s/;.*$//\' | awk \'{print $1"\t"($2-10)"\t"($2+10)"\t"$3"\\n"$4"\t"($5-10)"\t"($5+10)"\t"$3;}\'  > ',outName,'.bed'  ,sep="")  )

