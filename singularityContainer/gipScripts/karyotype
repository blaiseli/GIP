#First generate genome coverage files (.covPerNt) where the sequencing depth of each nucleotide is normalised by the median genomic coverage
#Then given a list of gzipped .covPerNt files (--file), this script downsample the covPerNt scores (e.g. by binning), then convert the bin scores to somy scores which will be used for the boxplots and statistics

#The somy score is defined as the downsampled score (e.g. bin score) divided by the median downsampled score of a chromosome deemed to be disomic and multiplied by 2
#If no disomic chromosome is deemed, the somy score is just the downsampled score multiplied by 2
#To assess what chromosome is disomic you can do a dry run of the script and pick a chromsome that has median cenetered on 2 and does not vary much across the various samples

#To test whether the chromosome coverage varies in different conditions in theory one could use a wilcoxon (default), ks or aov test.
#In practice, since there are many many observations (nucleotide) the distributions of the coverages will look always statistically significant (even if from the boxplot sometimes you can see they are very very similar).
#Since the coverage vectors are big the statistical test have an hard time (wilcoxon or ks tests return mostly pvalues of 0 and 1).
#that is why it is needed to adopt a downsampling approach. It simply bins the chromosomes and estimate the median coverage of each bin (--window).
#It works much better than the fourier approach.
#As an option (--selectQuantiles) out of each distribution of bins it considers just those between the 10th and the 90th quantile, so to strip out outliers bins. This is because outliers, hotpost loci can also artificially return into statistically significant comparisons, while in fact the genomic coverage distributions are very similar (except for these outliers)

#the script runs Wilcoxon, Kolmogorov-Smirnov and AOV tests on the downsampled data for each comparison and returns one table for each test.
#it also return the difference between the median downsampled somy score for each chromosome and for each comparison

#To compare coverage distribution shapes the script generates qqplots, comparing the quantiles of the two downsampled distributions. If the dots (quantiles) are on the diagonal, then they distributions have the same shape.

#use --pcMapqFiles to remove the bases where the percent of mapping reads with good MAPQ is < 50%


#WARNING: since the coverage vectors of a chromosome in two conditions have the same length, in fact the qqplots is equivalent to sort the two vectors and plot one against the other. So the coordinates x,y of the points are the coverage score in the two conditions (you have as many quantiles as nucleotides, not a fixed quantile interval, like the 25%)
#WARNING: Converting covPerNt scores to somy scores first, and then downsample (e.g. binning) would results in slightly differet results (medians not exactly centered on 2)


suppressPackageStartupMessages(library("argparse"))
parser <- ArgumentParser(description="Compare the chromosome sequencing coverage distributions")
parser$add_argument("--samples" , nargs="+", required=TRUE, help="Sample names. It determines the plotting order [required]" )
parser$add_argument("--gipOut"  , required=TRUE , help="GIP output directory [required]")
parser$add_argument("--outName" , help="Output name. [default %(default)s]" , default="NA")
parser$add_argument("--ylim" , nargs="+" , type="double" , help="min and max ylim used in the plot. [default %(default)s]" , default=c(0,10))
parser$add_argument("--chrs"    , nargs="+" , help="chromosomes to use. If not defined, it considers the chromosomes selected at gip runtime [default %(default)s]" , default="NA")
parser$add_argument("--makeQqplots" , action="store_true" , help="for all samples combinations, and for each chromosome it computes qQplots [default %(default)s]" , default=FALSE)
parser$add_argument("--window" , type="integer" , help="split each chr in chunks of this size, then take mean coverage out of each window to compare ditributions [default %(default)s]" , default=2500)
parser$add_argument("--selectQuantiles" , help="remove bins with coverage <10 and >90 quantiles (requires --window >1) [default %(default)s]" , default="no")
parser$add_argument("--disomicChr"  , help="normalize by this chromosome [default %(default)s]", default="NA" )
parser$add_argument("--customColors", help="provide a file with header \"SAMPLE HEX\" as first two columns, specifying the color for each sample [default %(default)s]", default="NA" )
parser$add_argument("--geom" , help="select boxplot or violin [default %(default)s]" , default="boxplot")
parser$add_argument("--pooled" , action="store_true" , help="flag. pool together all the samples (i.e. one box per chromosome representing the coverage values of all samples) [default %(default)s]" , default=FALSE)
parser$add_argument("--debug"  , action="store_true" , help="dump session and quit [default %(default)s]" , default=FALSE)
args <- parser$parse_args()
#patch NA
for (n in names(args)){if(args[[n]][1] == "NA"){args[[n]] <- NA}  }
for (n in names(args)){assign(n,args[[n]]) }


#functions
wilcoxonTest <- function (contrasts){
  allPvalsWilcox <- NULL
  for (i in 1:length(contrasts$V1)){ 
    x <- as.character(contrasts[i,])
    contrastPvalsWilcox <- NULL
    for (chr in chrs) {
      #select the score for each chr in the two samples
      a <- subset(allSamples[[x[1]]], allSamples[[x[1]]]$chromosome == chr)$score
      b <- subset(allSamples[[x[2]]], allSamples[[x[2]]]$chromosome == chr)$score
      chrPvalW <- wilcox.test(a,b)$p.value
      contrastPvalsWilcox <- c(contrastPvalsWilcox , chrPvalW)
    }
    #combine contrast wilcox pvals
    contrastPvalsWilcox <- t(as.data.frame(contrastPvalsWilcox))
    row.names(contrastPvalsWilcox) <- paste(x[1],"_VS_",x[2],sep="")
    as.data.frame(rbind(allPvalsWilcox , contrastPvalsWilcox)) -> allPvalsWilcox
  }
  #write wilcox
  names(allPvalsWilcox) <- chrs
  allPvalsWilcox$sample <- row.names(allPvalsWilcox) ; allPvalsWilcox <- allPvalsWilcox[,c("sample",chrs)]
  return(allPvalsWilcox)
}
KSTest <- function (contrasts){
  allPvalsKS <- NULL
  for (i in 1:length(contrasts$V1)){ 
    x <- as.character(contrasts[i,])
    contrastPvalsKS <- NULL
    for (chr in chrs) {
      #select the score for each chr in the two samples
      a <- subset(allSamples[[x[1]]], allSamples[[x[1]]]$chromosome == chr)$score
      b <- subset(allSamples[[x[2]]], allSamples[[x[2]]]$chromosome == chr)$score
      chrPvalK <- ks.test(a,b)$p.value
      contrastPvalsKS     <- c(contrastPvalsKS     , chrPvalK)
    }
    #combine contrast KS pvals
    contrastPvalsKS <- t(as.data.frame(contrastPvalsKS))
    row.names(contrastPvalsKS) <- paste(x[1],"_VS_",x[2],sep="")
    as.data.frame(rbind(allPvalsKS , contrastPvalsKS)) -> allPvalsKS
  }
  #write KS
  names(allPvalsKS) <- chrs
  allPvalsKS$sample <- row.names(allPvalsKS) ; allPvalsKS <- allPvalsKS[,c("sample",chrs)]
  return(allPvalsKS)
}
AOVTest <- function (contrasts){
  allPvalsAOV <- NULL
  for (i in 1:length(contrasts$V1)){ 
    x <- as.character(contrasts[i,])
    contrastPvalsAOV <- NULL
    for (chr in chrs) {
      #select the score for each chr in the two samples
      a <- subset(allSamples[[x[1]]], allSamples[[x[1]]]$chromosome == chr)$score
      b <- subset(allSamples[[x[2]]], allSamples[[x[2]]]$chromosome == chr)$score
      tmpDf    <- data.frame( score=c(a , b) , sample=c(rep("a",length(a))  , rep("b",length(b))) , stringsAsFactors=F )
      chrPvalA <- summary(aov(score ~ sample , tmpDf))[[1]]$Pr[1]
      contrastPvalsAOV    <- c(contrastPvalsAOV    , chrPvalA)
    }
    #combine contrast AOV pvals
    contrastPvalsAOV <- t(as.data.frame(contrastPvalsAOV))
    row.names(contrastPvalsAOV) <- paste(x[1],"_VS_",x[2],sep="")
    as.data.frame(rbind(allPvalsAOV , contrastPvalsAOV)) -> allPvalsAOV
  }
  #write AOV
  names(allPvalsAOV) <- chrs
  allPvalsAOV$sample <- row.names(allPvalsAOV) ; allPvalsAOV <- allPvalsAOV[,c("sample",chrs)]
  return(allPvalsAOV)
}
deltaMedians <- function (contrasts){
  allDeltas <- NULL
  for (i in 1:length(contrasts$V1)){ 
    x <- as.character(contrasts[i,])
    contrastDeltas <- NULL
    for (chr in chrs) {
      #select the score for each chr in the two samples
      a <- subset(allSamples[[x[1]]], allSamples[[x[1]]]$chromosome == chr)$score
      b <- subset(allSamples[[x[2]]], allSamples[[x[2]]]$chromosome == chr)$score
      delta <- median(a) - median(b)
      contrastDeltas    <- c(contrastDeltas    , delta)
    }
    #combine contrast AOV pvals
    contrastDeltas <- t(as.data.frame(contrastDeltas))
    row.names(contrastDeltas) <- paste(x[1],"_VS_",x[2],sep="")
    as.data.frame(rbind(allDeltas , contrastDeltas)) -> allDeltas
  }
  #write AOV
  names(allDeltas) <- chrs
  allDeltas$sample <- row.names(allDeltas) ; allDeltas <- allDeltas[,c("sample",chrs)]
  return(allDeltas)
}
qqplots <- function (contrasts){
  for (i in 1:length(contrasts$V1)){ 
    x <- as.character(contrasts[i,])
    for (chr in chrs) {
      #select the score for each chr in the two samples
      a <- subset(allSamples[[x[1]]], allSamples[[x[1]]]$chromosome == chr)$score
      b <- subset(allSamples[[x[2]]], allSamples[[x[2]]]$chromosome == chr)$score        
      #qqplot
      system(paste("mkdir -p qqplots_",outName,sep=""))
      pdf(paste("qqplots_",outName,"/",x[1],"_VS_",x[2],"_chr",chr,".pdf",sep=""))
      q <- qqplot(a,b,xlab=paste("quantiles",x[1]),ylab=paste("quantiles",x[2]),main=paste("qqplot chr",chr))
      abline(1,1)
      fit <- lm(q$y ~ q$x)
      abline(fit,col="red")
      invisible(dev.off())

    }
  }
}
removeLowMAPQ <- function (df,n) {
    fName <- paste0(gipOut,"/samples/",n,"/",n,".pcMapqPerNt.gz")
    dfMQ  <- data.frame(fread(paste("gunzip -c", fName),colClasses=list(character=1)) ,stringsAsFactors=F )
    names(dfMQ) <- c("chromosome","position","pcMapq") 
    dfMQ$tag <- paste0(dfMQ$chromosome,"_",dfMQ$position)
    df$tag <- paste0(df$chromosome,"_",df$position)
    df$pcMapq <- dfMQ[match(df$tag,dfMQ$tag),"pcMapq"]
    df <- df[df$pcMapq > 50, c("chromosome","position","score")]
    return(df)
}
compressCovPerNt <- function (df) {
    outDf <- NULL
    for (chr in chrs) {
        tmpChr <- subset(df, df$chromosome == chr)
        a <- c()
        if (window > 1){
            #binning
            a <- sapply(split(tmpChr$score, ceiling(seq_along(tmpChr$score)/window)),mean)
            if (selectQuantiles == "yes"){
                a <- subset(a , ((a > quantile(a,0.1)) & (a < quantile(a,0.9))) )
            }
        }
        outDf <- rbind(outDf,data.frame(chromosome=chr,position=1:length(a),score=a))
    }
    return(outDf)
}

#libraries
suppressPackageStartupMessages(library("data.table"))
suppressPackageStartupMessages(library("ggplot2"))
suppressPackageStartupMessages(library("gtools"))
suppressPackageStartupMessages(library("ggridges"))
suppressPackageStartupMessages(library("openxlsx"))
options(datatable.fread.input.cmd.message=FALSE)
if(debug){save.session("session_DEBUG_karyotype");quit()}

#setup
outDir <- paste0(gipOut,"/sampleComparison/")
system(paste0("mkdir -p ", outDir))
if (is.na(outName)){
  outName <- paste0(outDir,"karyotype")
}
if (is.na(ylim[1])){
  ylim = c(0,10)
} else {
  ylim <- as.numeric(ylim)
}
if (is.na (chrs[1])){ 
  chrs <- as.character(read.table(paste0(gipOut,"/samples/",samples[1],"/chrCoverageMedians_",samples[1]),header=T)[,1])
}
#sanity check
if (!is.na(disomicChr) & ! (disomicChr %in% chrs)) {
    stop("ERROR. disomicChr needs to be included in --chrs")
    quit(save = "no", status = 1, runLast = FALSE)  
}

#read .covPerNt files in a list
allSamples <- list()
for (i in 1:length(samples)){
    n = samples[i]
    fName = paste0(gipOut,"/samples/",n,"/",n,".covPerNt.gz")
    allSamples[[n]]    <- fread(paste("gunzip -c", fName),colClasses=list(character=1))
    names(allSamples[[n]]) <- c("chromosome","position","score") 
    allSamples[[n]] <- allSamples[[n]][allSamples[[n]]$chromosome %in% chrs,] 
    #remove lo MAPQ
    allSamples[[n]] <- removeLowMAPQ(data.frame(allSamples[[n]] , stringsAsFactors=F),n)
    #compress
    allSamples[[n]]        <- compressCovPerNt(allSamples[[n]])
    allSamples[[n]]$sample <- n
    #convert score to somy score
    if(!is.na(disomicChr)){
        normFact  <-  median(allSamples[[n]][ allSamples[[n]]$chromosome == disomicChr ,"score"])
        allSamples[[n]]$score <- allSamples[[n]]$score / normFact
    }
    allSamples[[n]]$score <- allSamples[[n]]$score * 2
}

#reformat
AllSamplesDf <- do.call(rbind,allSamples)
AllSamplesDf$sample     <- factor(AllSamplesDf$sample , levels=samples )
AllSamplesDf$chromosome <- factor(AllSamplesDf$chromosome , levels=chrs)

#customColors
if(! is.na(customColors)){
  customColDf  <- read.table(customColors,header=T,stringsAsFactors=F)
  customColVec <- customColDf$HEX
  names(customColVec) <- customColDf$SAMPLE
  customColVec <- gsub(x=customColVec,pattern="^",replacement="\\#")
}

#plot
pdf(paste(outName,".pdf",sep=""),width=16)
p <-  ggplot(AllSamplesDf, aes(chromosome, score)) 
if (geom == "violin"){
  if (pooled){
    p <- p + geom_violin(fill="lightblue") 
  } else {
    p <- p + geom_violin(aes(fill = sample)) 
  }
} else if (geom == "boxplot") {
  if (pooled){
    p <- p + geom_boxplot(fill="lightblue"   , outlier.shape = NA) 
  } else {
    p <- p + geom_boxplot(aes(fill = sample) , outlier.shape = NA) 
  }
}
p <- p + coord_cartesian(ylim = c(ylim[1],ylim[2]) ) + ylab("somy score") + theme_minimal() + theme(axis.text.x = element_text(angle = 90, hjust = 1) , legend.title = element_text(size=13,face="bold") , axis.title = element_text(size=13,face="bold") , panel.grid.major = element_line(size=1))
if(! is.na(customColors)){
  p1 <- p + scale_fill_manual(values=customColVec)
} else {
  p1 <- p + scale_fill_brewer(palette="Dark2")
}
print(p1)

#ridges (pooled data, including all samples)
print( ggplot(AllSamplesDf, aes(x = score, y = chromosome, fill = stat(x))) + geom_density_ridges_gradient(scale = 3, rel_min_height = 0.01) +   scale_x_continuous(expand = c(0, 0), limits=c(ylim[1],ylim[2])) +  scale_y_discrete(expand = c(0, 0)) + scale_fill_viridis_c(name = "score", option = "C") + theme_ridges(font_size = 13, grid = TRUE) )
invisible(dev.off())

#compare distributions
allTables <- list()
if(length(samples) > 1){
  contrasts <- as.data.frame(combinations(n=length(samples),r=2,samples),stringsAsFactors=F)
  allTables[["wilcoxonTest"]]     <- wilcoxonTest(contrasts)
  allTables[["KSTest"]]           <- KSTest(contrasts)
  allTables[["AOVTest"]]          <- AOVTest(contrasts)
  allTables[["diffMedianChrCov"]] <- deltaMedians(contrasts)
  if (makeQqplots){
    qqplots(contrasts)
  }
}

#table summarizing median scores per chromosome
allMedians <- list()
for (n in names(allSamples)){
    medians <- NULL
    for (chr in chrs) {
        medians <- c(medians , as.numeric(median(subset(allSamples[[n]], allSamples[[n]]$chromosome == chr)$score)))
    }
    names(medians)  <- chrs
    allMedians[[n]] <- medians
}
allMediansDf <- as.data.frame(do.call(rbind,allMedians),stringsAsFactors=F)
newnames <- names(allMediansDf)
allMediansDf$sample <- rownames(allMediansDf)
allTables[["medianChrCoverage"]] <- allMediansDf[,c("sample",newnames)]
write.xlsx(file=paste0(outName,".xlsx") , x=allTables , asTable=TRUE)

