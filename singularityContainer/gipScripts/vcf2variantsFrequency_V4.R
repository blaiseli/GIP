#Read a VCF file, a file with the chromosome sizes (e.g. chrName chrSize) and the reference assembly used to call the variants(multiFASTA)

#For each variant it computes the variant read frequencies (VRFs). i.e. reads on the variant/(reads on the variant + reads on the reference)
#It considers two sets of variants:
#   A) those with 1 alternative wrt the reference
#   B) all the variants
#In A) every position corresponds to a different variant. So it is non-redundant, but the positions with multiple aleles are missing.
#In B) for each variant position and for each of its variants, it computes the variant frequency.
#This means that B) is redundant as variant positions are counted multiple times (as many times as the alternatives variants there are)
#Worse than that, in B) the frequency estimations aren't precise (as for the current version of the script). this is because the frequency of each allele is estimated by AO/AO+RO, which is, by the fracion of reads that support the allele over the sum of reads that support the allele and the reference. But if there are reads supporting other alleles, this should be added to the denominator too. In other words, one should that the frequency of each allele with respect to the coverage dept of that nucleotide (not relative to the reference)
#Specify --variants ["single"| "all"] to chose whether you wanna A) or B)
#The script applies various filters on the variants and generate plots

#OUTPUT
#-_df.gz:			data frame with all the filtered variants that are also plotted
#-_vcf.gz:			vcf with all the filtered variants that are also plotted
#-_summary: 		tot variants per chromosome normalised by chromosomeKilobases 
#-_summary: 		distribution of variant frequencies per chromosome
#-_summary:			histogram of variant frequencies versus position per chromosome
#-_summary:                     faceting position vs VRF
#-_coverageVSfreq: 	dotplot of frequency VS coverage (or AO) of each variant. Variants on multi-copy genes or chromosomes will be visible as clouds
#-_variantType.pdf:	barplot showing the count of variant types, and coulouring by mean variant type frequency. Slide two shows the combination of equivalent mutation types (e.g. A_C is added to T_G)
#-_onePlotPerChr: 	distributions and dotplots as in the summary (but with a chromosome per plot). Here the dots (variants) are coloured by average base quality
#-_combinedDotPlotAndDistribution:	Combined dotplot and histogram. Here the dots (variants) are coloured by sequencing depth
#-context:			Considering the context sequence of the variants of each variant type it generates a logo plot to see if there is some motif liked to the mutation type
#-_pseudoReference.gz:				OPTIONAL: if generatePseudoReference is yes, it will return another reference sequence incorporating the filtered variants

#NOTES
#Low frequencies (< 0.2) are likely to be noise (sequencing error), i.e. the sample genotype is probably the same as the reference and there is no actual variant.
#For high frequencies (> 0.8) the alternative variant is likely to be homozygous
#In a diploid region the expected heterozygous frequency is 0.5.
#The frequency is supposed to be ~0.33 or ~0.66 for trisomic region

#If your reads do not correspond to a species that is not exactly as the one in reference assembly used (but a close species for instance) this may cause artifacts
#For instance if the species has at a certain position an A for both chromosomes, but the wrong reference says that it is a C, then this will count as alternative variant (A) homozygous, while in fact it is just a reference problem (as it should not be counted as a variant).
#Similarly if the species at a certain position is heterozygous (A , C), but the wrong reference says that it is a G instead of and A, then this would count as a multi allele hereozygous variant (A , C) while in fact should be just a single allele variant (C)

#This version  of the script is able to apply stricter filtering to SNVs called on homopolymers (as they could be alignment artifact caused by indels generated by polymerase slippage, in vivo, or during the PCR amplification). Then it is also generate logo plots on the context sequence of each variant type. This latter is the same as what variantTypeContext.R does, but faster

#NOTE! As Jen pointed in one email (see gmail 16/01/2017) sometimes the VCF files aren't adequate for the package VariantAnnotation to well determine the variant end point. A genuine vcf file should have in the ALT and REF fields the bases or the length of the variation. e.g.:
#chr1    599481  .       AT      A       .       PASS    INFO_COLUMN
#In practice delly just puts the name of the structural variant (e.g. <DEL>). So VariantAnnotation does not know the length of the structural variation. You have to use the END column in info(vcf) to have the real variant end. This is not the default of VariantAnnotation because you cannot rely always on the END field. For instance freebayes does not use it. Because of this reason you need to check the ALT REF and END fields of the vcf file and then specify --useENDfield [yes|no] accordingly. For delly version 0.6.7 this should be set to yes. This is unless the variant type is a traslocation (TRA). In this case you need to set it to "no" because the end point is used to compute the variant length, and if it is a traslocation thiss does not make any sense and can even be negative. For freebayes v1.0.1-2-g0cb2697 you should put "no" because the END field is "NA" while the ALT field is good. 

#######
#######
#######

#################################################
#               CONFIGURATION
#################################################
suppressPackageStartupMessages(library("argparse"))
# create parser object
parser <- ArgumentParser()
# specify our desired options # by default ArgumentParser will add an help option
parser$add_argument("--vcfFile"     , help="vcf file to load. [default %(default)s]" )
parser$add_argument("--chrSizeFile" , help="file with chromosome length like the one returned by fetchChromSizes [default %(default)s]" )
parser$add_argument("--outdir"      , help="Basename for the outDir [default %(default)s]" , default="out_vcf2variantsFrequency" )
parser$add_argument("--reference"   , help="reference assembly in FASTA format [default %(default)s]")
parser$add_argument("--generatePseudoReference"  , help="make a pseudoreference incorporating the filtered SNVs to the reference assembly [default %(default)s]", default="yes")
parser$add_argument("--selectedChrs" , nargs="+" , help="select the chromosomes of interest [default %(default)s]" , default="NA" )
parser$add_argument("--variants"     , help="specify whether you whant just single alternative variants (e.g. A -> C) or including also the multi-allele variants (e.g. A -> C,T). all is deprecated since the allele frequency is measured with respect to the reference support, but for multi allele variants this might be  [default %(default)s]" , default="single" )
parser$add_argument("--snvOnly"      , help="select just single nucleotide variants [default %(default)s]" , default="yes" )
parser$add_argument("--discardGtfRegions" , help="SNVs overlapping in any strand the positions specified in the gtf file are discarded (e.g. repeats annotations) [default %(default)s]" , default="NA")
parser$add_argument("--minFreq" , type="double" , help="min variant frequency [default %(default)s]" , default="0")
parser$add_argument("--maxFreq" , type="double" , help="max variant frequency. Set to 0.99 to remove homozygous variants (which can be reference assembly errors) [default %(default)s]" , default="1")
parser$add_argument("--MADrange" , type="double" , help="define how many MAD from the median to consider. Activated by --chrCoverageMediansFile  [default %(default)s]" , default="2")
parser$add_argument("--minDp"   , type="integer" , help="min sequencing depth on the loci  [default %(default)s]" , default="0")
parser$add_argument("--maxDp"   , type="integer" , help="max sequencing depth on the loci [default %(default)s]" , default="1000")
parser$add_argument("--chrCoverageMediansFile"  , help="file with the medianCoverage, maxDp and minDp for each chr. It has priority over --minDp and --maxDp. Recommended since different chromosomes can have different median coverages (in different experiments and in different ploydies) [default %(default)s]" , default="NA")
parser$add_argument("--minAlternatePercent"  , type="double" , help="Activated by --chrCoverageMediansFile. Since different chromosomes have different coverages, they should have different variants counts thresholds (min AO). This variable dinamically changes the min alternate count (minAO) to be always at least XXpercent of the median chromosome coverage (It should be similar/equivalent to setting minFreq) [default %(default)s]" , default="0")
parser$add_argument("--minAO" , type="integer" , help="min count of reads supporting the variant (recommended around 3)[default %(default)s]" , default="0")
parser$add_argument("--minAOhomopolymer" , type="integer" , help="min count of reads supporting the variant if this maps to an homopolymer. Normally you want this filter higher than the value in --minAO (recommended around 30) [default %(default)s]" , default="0")
parser$add_argument("--contextSpan", type="integer" , help="bases on each side of the SNVs to be considered for the context plots and the homopolymer filtering [default %(default)s]" , default="5")
parser$add_argument("--homopolymerFreq" , type="double" , help="Base frequency in the SNV context above which the region is called homopolymer [default %(default)s]" , default="0.4")
parser$add_argument("--minQr" , type="integer" , help="DEPRECATED. min Reference allele quality sum in phred. Depending on the readDepth the sum of the qualities con be very different. It is better to filter mean quality (--minMQMR)  [default %(default)s]" , default="0")
parser$add_argument("--minQa" , type="integer" , help="DEPRECATED. min Alternate allele quality sum in phred. Depending on the readDepth the sum of the qualities con be very different. It is better to filter mean quality (--minMQM)  [default %(default)s]" , default="0")
parser$add_argument("--minMQMR" , type="double" , help="min mean mapping quality of observed reference alleles    [default %(default)s]" , default="20")
parser$add_argument("--minMQM"  , type="double" , help="min mean mapping quality of observed alternate alleles  [default %(default)s]" , default="20")
parser$add_argument("--densityYlim" , help="graphical parameter: coord_cartesian ylim density plots [default %(default)s]" , default="NA")
parser$add_argument("--histogramYlim" , help="graphical parameter: coord_cartesian ylim (counts) histogram plots [default %(default)s]" , default="NA")
parser$add_argument("--alphaCovergeVSfrequency" , type="integer" , help="graphical parameter: alpha transparency in _coverageVSfreq.pdf plot [default %(default)s]" , default="255")
parser$add_argument("--useENDfield" , help="VariantAnnotation uses the info(vcf) END field to define the variant end [yes|no]. Not recommended if you process freebayes vcfs [default %(default)s]" , default="no")
parser$add_argument("--debug"  , action="store_true" , help="Dump session and quit" , default=FALSE)
args <- parser$parse_args()
#patch NA
for (n in names(args)){if(args[[n]][1] == "NA"  ){args[[n]] <- NA  } }
for (n in names(args)){assign(n,args[[n]]) }
if(debug){library(session);save.session("session_DEBUG");quit()}
#fix type
densityYlim   <- as.numeric(densityYlim)
histogramYlim <- as.numeric(histogramYlim)


###########
#functions#
###########
addTransparency <- function(colors,alpha){
	newcolors = NULL 
	for(col in colors){
		z = col2rgb(col) ; 
		newcolors = c(newcolors, rgb(z[1], z[2], z[3], alpha, maxColorValue=255)) 
	}
return(newcolors)
}
plotAll <- function(varPerChrNormalised , df , outName , chrSizes){
    df$chr <- factor(df$chr,levels=chrs)
    
    #tot var perChr (normalised)
    png(paste0(outdir,"/",outName,"_totVarPerChr.png"),type='cairo' , width = 1000, height = 1000)
    varPerChrNormalisedDf <- as.data.frame(varPerChrNormalised)
    p <- ggplot(data=varPerChrNormalisedDf, aes(x=CHRforEachAllele, y=Freq)) +  geom_bar(stat="identity",fill="#69b3a2") 
    p <- p + coord_flip() + theme_bw() + ylab("chromosome") + xlab("number of SNVs per Kb")
    p <- p + theme(axis.text=element_text(size=18), axis.title=element_text(size=21,face="bold"))
    print(p)
    dev.off()

    #all density plots
    png(paste0(outdir,"/",outName,"_allDensities.png"),type='cairo', width = 1000, height = 1000 )
    densities <- ggplot(df , aes(x=freq)) + geom_density() + xlim(0,1) + theme_bw() + facet_wrap(~ chr, scales = "free") 
    densities <- densities + theme(axis.text.x = element_text(angle = 90, hjust = 1) , axis.text=element_text(size=14), axis.title=element_text(size=21,face="bold")) + xlab("VRF")
    if (! is.na(densityYlim)){ densities <- densities + coord_cartesian(ylim=c(0,densityYlim))}
    print(densities)
    dev.off()
    
    #all histogram plots (actual counts of variants in bins of 0.10)
    png(paste0(outdir,"/",outName,"_allHists.png"),type='cairo', width = 1000, height = 1000)
    hist <- ggplot(df , aes(x=freq)) + geom_histogram(position = "identity" , bins=10, binwidth=0.1, boundary = -0.05, color = "black", fill="blue") + theme_bw() 
    hist <- hist + theme(axis.text.x = element_text(angle = 90, hjust = 1,vjust = 0.5,size =12), axis.text.y=element_text(size=18) , axis.title=element_text(size=21,face="bold")) 
    hist <- hist + scale_x_continuous(breaks=seq(0,1,0.1)) + facet_wrap(~ chr) + xlab("VRF") 
    if (! is.na(histogramYlim)){ hist <- hist + coord_cartesian(ylim=c(0,histogramYlim))}
    print(hist)
    dev.off()
    
    #all histogram plots sqrt scaled (the y axis reports the real counts, but the size of the bars is sqrt scaled)
    png(paste0(outdir,"/",outName,"_allHistsSqrt.png"),type='cairo', width = 1000, height = 1000)
    histSqrt <- ggplot(df , aes(x=freq)) + geom_histogram(position = "identity" , bins=10,binwidth=0.1, boundary = -0.05, color = "black", fill="red") + theme_bw() 
    histSqrt <- histSqrt + theme(axis.text.x = element_text(angle = 90, hjust = 1,vjust = 0.5,size =12), axis.text.y=element_text(size=17) , axis.title=element_text(size=21,face="bold"))  
    histSqrt <- histSqrt + scale_x_continuous(breaks=seq(0,1,0.1)) + facet_wrap(~ chr) + scale_y_sqrt() + ylab("counts sqrt scale")
    print(histSqrt)
    dev.off()
    
    #VRF vs position (faceting)
    png(paste0(outdir,"/",outName,"_VRFvsPosFaceting.png"),type='cairo', width = 1000, height = 1000)
    #prepare df with x and y axes range
    axesDf <- data.frame(x = numeric(), y = numeric(), chr = character())
    for (chr in chrSizes$chr){
     size <- chrSizes[ match(chr , chrSizes$chr) , "size" ]
     axesDf <- rbind(axesDf, data.frame(x = 0    , y = 0, chr = chr))
     axesDf <- rbind(axesDf, data.frame(x = size , y = 1, chr = chr))
    }
    p <- ggplot() + geom_hline(yintercept=.5, linetype="dashed", color = "blue", size=.5) 
    p <- p + geom_hline(yintercept=c(.33,.66), linetype="dotted", color = "red", size=.5) + geom_point(data=df , aes(x=position, y=freq))
    p <- p + geom_blank(data = axesDf, aes(x = x, y = y)) + theme_bw() + facet_wrap(~chr, scales = "free") + xlab("position") + ylab("frequency") 
    p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1,  size =12), axis.text.y=element_text(size=17) , axis.title=element_text(size=21,face="bold"))
    print(p)
    dev.off()

    #count variantTypes and color by mean variantType frequency
    png(paste0(outdir,"/",outName,"_variantType.png"),type='cairo', width = 1000, height = 1000)
    meanFrequenciesPerMutation <- NULL;  for (mut in unique(df$ref_alt)) { mf <- mean(df[df$ref_alt == mut , "freq"]); names(mf)<-mut; meanFrequenciesPerMutation <- c(meanFrequenciesPerMutation , mf)   }
    mutId <- names(meanFrequenciesPerMutation)
    mutDf <- data.frame(variantId=mutId, meanFrequenciesPerMutation= meanFrequenciesPerMutation , mutationCount=as.numeric(table(df$ref_alt)[mutId]))
    p <- ggplot(mutDf, aes(y=mutationCount,x=variantId,fill=meanFrequenciesPerMutation)) + geom_bar(stat="identity") + theme_minimal() 
    p <- p + scale_fill_continuous(guide = guide_legend(title = "mean varyant type\nfrequency")) + xlab("variant type") + ylab("number")
    p <- p + theme(axis.text=element_text(size=20), axis.title=element_text(size=23,face="bold"), legend.title=element_text(size=23), legend.text=element_text(size=20))
    print(p)
    dev.off()
  
    #combining equivalent types 
    png(paste0(outdir,"/",outName,"_variantTypeCombined.png"),type='cairo', width = 1000, height = 1000)
    mutDfCombo <- NULL
    mutDfCombo <- rbind(data.frame(variantId="A_C,T_G" , meanFrequenciesPerMutation=mean(c(mutDf["A_C","meanFrequenciesPerMutation"], mutDf["T_G","meanFrequenciesPerMutation"])) , mutationCount=sum(c(mutDf["A_C","mutationCount"], mutDf["T_G","mutationCount"]))) , mutDfCombo )
    mutDfCombo <- rbind(data.frame(variantId="A_G,T_C" , meanFrequenciesPerMutation=mean(c(mutDf["A_G","meanFrequenciesPerMutation"], mutDf["T_C","meanFrequenciesPerMutation"])) , mutationCount=sum(c(mutDf["A_G","mutationCount"], mutDf["T_C","mutationCount"]))) , mutDfCombo )
    mutDfCombo <- rbind(data.frame(variantId="A_T,T_A" , meanFrequenciesPerMutation=mean(c(mutDf["A_T","meanFrequenciesPerMutation"], mutDf["T_A","meanFrequenciesPerMutation"])) , mutationCount=sum(c(mutDf["A_T","mutationCount"], mutDf["T_A","mutationCount"]))) , mutDfCombo )
    mutDfCombo <- rbind(data.frame(variantId="C_A,G_T" , meanFrequenciesPerMutation=mean(c(mutDf["C_A","meanFrequenciesPerMutation"], mutDf["G_T","meanFrequenciesPerMutation"])) , mutationCount=sum(c(mutDf["C_A","mutationCount"], mutDf["G_T","mutationCount"]))) , mutDfCombo )
    mutDfCombo <- rbind(data.frame(variantId="C_G,G_C" , meanFrequenciesPerMutation=mean(c(mutDf["C_G","meanFrequenciesPerMutation"], mutDf["G_C","meanFrequenciesPerMutation"])) , mutationCount=sum(c(mutDf["C_G","mutationCount"], mutDf["G_C","mutationCount"]))) , mutDfCombo )
    mutDfCombo <- rbind(data.frame(variantId="C_T,G_A" , meanFrequenciesPerMutation=mean(c(mutDf["C_T","meanFrequenciesPerMutation"], mutDf["G_A","meanFrequenciesPerMutation"])) , mutationCount=sum(c(mutDf["C_T","mutationCount"], mutDf["G_A","mutationCount"]))) , mutDfCombo )
    p <- ggplot(mutDfCombo, aes(y=mutationCount,x=variantId,fill=meanFrequenciesPerMutation)) + geom_bar(stat="identity") + theme_minimal()  
    p <- p +  scale_fill_continuous(guide = guide_legend(title = "mean variant type\nfrequency")) + xlab("variant type") + ylab("number")
    p <- p + theme(axis.text=element_text(size=20), axis.title=element_text(size=23,face="bold"), legend.title=element_text(size=23), legend.text=element_text(size=20))
    print(p)
    dev.off()
    
    #coverage vs VRF
    png(paste0(outdir,"/",outName,"_depthVsVRF.png"),type='cairo', width = 1000, height = 1000)
    p <- ggplot(data=df , aes(x=freq, y=totDepth)) + geom_point() + ylab("variant depth") + xlab("VRF") + theme_bw()
    p <- p + theme(axis.text=element_text(size=18), axis.title=element_text(size=21,face="bold"))
    print(p)
    dev.off()

    library("randomcoloR")
    allLetters     <- c(LETTERS ,letters)
    missingLetters <- length(allLetters) - length(selectedChrs)
    if(missingLetters < 0){ allLetters <- c(allLetters,rep(0,abs(missingLetters)))  }
    set.seed(1)
    palDf  <- data.frame(chr=selectedChrs,color=distinctColorPalette(length(selectedChrs)),symbol=allLetters[1:length(selectedChrs)])
    df <- merge(df,palDf,by="chr",all.x=TRUE,sort=F) 
    png(paste0(outdir,"/",outName,"_depthVsVRFletters.png"),type='cairo', width = 1000, height = 1000)
    p <- ggplot(data=df) + geom_text(aes(x=freq, y=totDepth , label=symbol , color=chr) ) + ylab("variant depth") + xlab("VRF") + theme_bw()
    p <- p + scale_color_manual("chromosomes", values = palDf$color , labels=palDf$chr ,breaks=palDf$chr)
    p <- p + guides(colour = guide_legend(override.aes = list(label = palDf$symbol)))
    p <- p + theme(axis.text=element_text(size=18), axis.title=element_text(size=21,face="bold"), legend.title=element_text(size=18), legend.text=element_text(size=16)) 
    print(p)
    dev.off()

    png(paste0(outdir,"/",outName,"_VRFvsAO.png"),type='cairo', width = 1000, height = 1000)
    p <- ggplot(data=df , aes(x=freq, y=AO)) + geom_point() + ylab("AO") + xlab("VRF") + theme_bw()
    p <- p + theme(axis.text=element_text(size=18), axis.title=element_text(size=21,face="bold"))
    print(p)
    dev.off()

    png(paste0(outdir,"/",outName,"_VRFvsAOletters.png"),type='cairo', width = 880, height = 880)
    p <- ggplot(data=df) + geom_text(aes(x=freq, y=AO , label=symbol , color=chr) ) + ylab("AO") + xlab("VRF") + theme_bw()
    p <- p + scale_color_manual("chromosomes", values = palDf$color , labels=palDf$chr ,breaks=palDf$chr)
    p <- p + guides(colour = guide_legend(override.aes = list(label = palDf$symbol)))
    p <- p + theme(axis.text=element_text(size=18), axis.title=element_text(size=21,face="bold"), legend.title=element_text(size=18), legend.text=element_text(size=16)) 
    print(p)
    dev.off()

    #individual plots (coloured by base quality)
    pdf(paste0(outdir,"/",outName,"_onePlotPerChr.pdf"))
    for (chr in chrs){
        dots <- ggplot(df [df$chr == chr,], aes(position,freq)) + geom_point(aes(colour=(MQM+MQMR)/2)) + xlim(0 , chrSizes[chrSizes$chr == chr, "size"]) + ylim(0,1) + theme_bw() + ggtitle(paste("chromosome",chr)) +  ylab("variant frequency") + scale_colour_gradient(low = "blue" , name="Avg\nbase\nQuality")
        print(dots)
        dens <- ggplot(df [df$chr == chr,], aes(x=freq)) + geom_density() + xlim(0,1) + theme_bw() + ggtitle(paste("chromosome",chr))
		if (! is.na(densityYlim)){ dens <- dens + coord_cartesian(ylim=c(0,densityYlim))}
        print(dens)
    }
    dev.off()

    #individual plots (coloured by variantTypes)
    df$ref_alt_combo <- df$ref_alt
    df$ref_alt_combo[df$ref_alt_combo == "A_C" | df$ref_alt_combo == "T_G"] = "A_C,T_G"
    df$ref_alt_combo[df$ref_alt_combo == "A_G" | df$ref_alt_combo == "T_C"] = "A_G,T_C"
    df$ref_alt_combo[df$ref_alt_combo == "A_T" | df$ref_alt_combo == "T_A"] = "A_T,T_A"
    df$ref_alt_combo[df$ref_alt_combo == "C_A" | df$ref_alt_combo == "G_T"] = "C_A,G_T"
    df$ref_alt_combo[df$ref_alt_combo == "C_G" | df$ref_alt_combo == "G_C"] = "C_G,G_C"
    df$ref_alt_combo[df$ref_alt_combo == "C_T" | df$ref_alt_combo == "G_A"] = "C_T,G_A"
    pdf(paste0(outdir,"/",outName,"_onePlotPerChr_colouredByVariantType.pdf"))
    for (chr in chrs){
        dots <- ggplot(df [df$chr == chr,], aes(position,freq)) + geom_point(aes(colour=ref_alt_combo)) + xlim(0 , chrSizes[chrSizes$chr == chr, "size"]) + ylim(0,1) + theme_bw() + ggtitle(paste("chromosome",chr)) +  ylab("variant frequency") + scale_color_brewer(palette="Accent")
        print(dots)
    }
    dev.off()

    #dotplot combined with marginal dist
    pl <- lapply(chrs, function(chr){
      sp2 <- ggplot(df[(df$chr == chr) , ], aes(position,freq)) + geom_point(aes(colour=log10(totDepth))) + xlim(0 , chrSizes[chrSizes$chr == chr, "size"]) + ylim(0,1) + theme_bw() +  ggtitle(paste("chromosome",chr)) + theme(legend.position="left" ) + ylab("variant frequency") + scale_colour_gradient(low = "black" , high="gold", name="log10\nSequencing\nDepth")
      ggMarginal(sp2 ,margins=c("y") , type = "histogram", fill = '#BDBBB6', col = '#403B3B')
    })
    ml <- marrangeGrob(pl, nrow=1, ncol=1 , top="")
    pdf(paste0(outdir,"/",outName,"_combinedDotPlotAndDistribution.pdf"))
    print(ml)
    dev.off() 
 
    #context
    system(paste0("mkdir -p ",outdir,"/context"))
    for (mut in unique(df$ref_alt)){
	  png(paste0(outdir,"/context/",outName,"_",mut,".png"),type='cairo')
	  tmpDf <- df[df$ref_alt == mut,]  
	  tmpDf <- data.frame(do.call('rbind', strsplit(as.character(tmpDf$context),'',fixed=TRUE)))
	  for(i in 1:length(tmpDf[1,]) ){
		tmpDf[,i]<- factor(tmpDf[,i],levels=c("A","C","G","T","N"))  
	  }
	  tmpDfCounts <- NULL; for(i in 1:length(tmpDf[1,]) ){  rbind(tmpDfCounts , table(tmpDf[,i]) ) -> tmpDfCounts  }
	  tmpDfFreq <- apply(tmpDfCounts,1,function(x){ x/sum(x)  } )
	  p <- makePWM(tmpDfFreq[1:4,])
	  seqLogo(p,ic.scale=T)
	  dev.off()
    }
}
normalise <- function (varPerChr , chrSizes ){
    kiloChrSize         <- chrSizes[match(names(varPerChr),chrSizes$chr),"size"] / 1000
    varPerChrNormalised <- varPerChr / kiloChrSize
    return(varPerChrNormalised)
}
makeDf <- function (chr , position , freq , AO , alt , depthForEachAllele , QaForEachAllele , QrForEachAllele , MQMforEachAllele , MQMRforEachAllele , ref_altForEachAllele){
    df <- data.frame(
      chr=chr,
      position=position ,
      freq=freq ,
      AO=AO,
      alt=alt,
      totDepth=depthForEachAllele ,
      QA=QaForEachAllele ,
      QR=QrForEachAllele ,
      MQM=MQMforEachAllele ,
      MQMR=MQMRforEachAllele,
      ref_alt=ref_altForEachAllele,
      stringsAsFactors=FALSE
    )
    #2nd filter round
    df <- filterDF(df)
    vcf <- vcf [ which ( paste(as.vector(seqnames(vcf)), as.vector(start(vcf)) , sep="_") %in% paste(df$chr,df$position,sep="_")  ) ,]
    #write filtered vcf and filtered df
    writeVcf(vcf , paste0(outdir,"/",variants,"Variants.vcf"))
    write.table(df,append=F,quote=F,sep="\t",row.names=F,col.names=T,file=paste0(outdir,"/",variants,"Variants.df"))
    system(paste0("gzip " , outdir,"/",variants,"Variants.df"))
    system(paste0("bgzip " , outdir,"/",variants,"Variants.vcf"))
    system(paste0("tabix -p vcf " , outdir,"/",variants,"Variants.vcf.gz"))
    if (generatePseudoReference == "yes"){makePseudoReference(df);}
    return(df)
}
filterDF <- function(df){
	#filter by VRF
	df <- df[(df$freq >= minFreq) & (df$freq <= maxFreq) , ]
	#filter SNV involving N
        df <- df[! grepl(x=df$ref_alt , pattern="N") , ]
	#add SNV sequence context
	context <- NULL; 
	for (i in 1:length(df$chr)){
		c   <- df[i,"chr"]
		p   <- df[i,"position"]
		#including N if the SNV is on the chr edge
		if ((p + contextSpan) > length(refAssembly[[as.character(c)]])) {
			terminalNs = (p + contextSpan) - length(refAssembly[[as.character(c)]])
			reducedContextSpan =  contextSpan - terminalNs
			seq <- subseq(refAssembly[[as.character(c)]], p - contextSpan, p + reducedContextSpan)
			seq <- toString(seq)
			seq <- paste0(seq,paste0(rep("N",terminalNs),collapse=""))
		} else if ((p - contextSpan) < 0) {
			startingNs = abs(p - contextSpan)+1
			reducedContextSpan =  contextSpan - startingNs
			seq <- subseq(refAssembly[[as.character(c)]], p - reducedContextSpan, p + contextSpan)
			seq <- toString(seq)
			seq <- paste0(paste0(rep("N",startingNs),collapse=""),seq)
		} else {
			seq <- subseq(refAssembly[[as.character(c)]], p - contextSpan, p + contextSpan)
			seq <- toString(seq)
        	}
        	rbind(context,seq)->context  
	}
	df$context <- context
	#homopolymer filtering
	homopolymers <- c()
	for (i in 1:length(df$context)){
		string      <- DNAString(df$context[i]); 
		homopolymer <- any ( alphabetFrequency(string,baseOnly=TRUE, as.prob=TRUE) > homopolymerFreq ); 
		homopolymers <- c(homopolymers,homopolymer)
	}
	toFilter <- (homopolymers) & (df$AO < minAOhomopolymer)
	df <- df[ ! toFilter, ]
	return(df)
}
makePseudoReference <- function (df){
	df$alt <- gsub(x=df$ref_alt,pattern="^(.+)_(.+)$",replacement="\\2",perl=T)
	for ( c in unique(df$chr)) { 
		pos <- df[df$chr == c, "position"]; 
		alt <- df[df$chr == c, "alt"];    
		for(i in 1:length(pos)) { 
			refAssembly[[as.character(c)]][pos[i]] = alt[i] 
		}      
	}	
	writeXStringSet(refAssembly, paste(outdir,"/","pseudoReference.fa",sep=""))
	system(paste("gzip " , outdir,"/","pseudoReference.fa",sep=""))
}
filterVCF <- function (vcf){
	#filter gtf regions
	if (! is.na(discardGtfRegions)){
		system ( paste0("grep -v '^#' ",discardGtfRegions," | cut -f 1,4,5 > ",outdir,"/_tmpRep.bed"))
		regBed <- read.table(paste0(outdir,"/_tmpRep.bed"),header=F,stringsAsFactors=F)
		system(paste0("rm ",outdir,"/_tmpRep.bed"))
		names(regBed) <- c("chr","start","end")
		regGr <- with(regBed, GRanges(chr, IRanges(start, end)))
		ov  <- findOverlaps(rowRanges(vcf),regGr)
		idx <- setdiff(1:length(vcf), queryHits(ov))
		vcf <- vcf[idx]
	}
	#filter chromosomes
	if(! is.na(selectedChrs[1])){
		 vcf <- vcf[as.character(seqnames(vcf)) %in% as.character(selectedChrs),] 
	}
	#filter by number of alleles
	howmanyalleles <- elementNROWS(alt(vcf))
	if(variants == "single"){
	    vcf   <- vcf[howmanyalleles==1]
	}
	#filter by variant type
	if(snvOnly == "yes"){
	    vcf   <- vcf[isSNV(vcf)]
	}
	#filter by variant base quality
    vcf <- vcf[(unlist(info(vcf)$QA) >= minQa) & (unlist(info(vcf)$MQM) >= minMQM) ,]
    #filter by reference base quality (if there's any reference supporting read)
    vcf <- vcf[! ( (unlist(info(vcf)$RO) > 0) & ((info(vcf)$QR < minQr) |  (info(vcf)$MQMR < minMQMR)) ) , ]
	#filter by count of variant supporting reads
	vcf <- vcf[unlist(geno(vcf)[["AO"]]) > minAO , ]
	#filter by coverage & % of variant supporting reads
	if (! is.na (chrCoverageMediansFile)){
		chrCoverageMedians <- read.table(chrCoverageMediansFile,stringsAsFactors=F,header=T)
		allVcfs <- list()
		for (r in 1:length(chrCoverageMedians[,1])) {
			chr    <- chrCoverageMedians[r,"CHR"]
			medCov <- chrCoverageMedians[r,"MEDIANCOV"]
			maxDp  <- chrCoverageMedians[r,"MEDIANCOVplus2MAD"]
			minAlternateCount <- (medCov / 100) * minAlternatePercent
			MAD     <- (maxDp - medCov) / 2
			madSpan <- MAD * MADrange
			minDp   <- medCov - madSpan
			maxDp   <- medCov + madSpan
			allVcfs[[chr]] <- vcf[(seqnames(vcf) == chr) & (info(vcf)$DP < maxDp) & (info(vcf)$DP > minDp) & (unlist(geno(vcf)[["AO"]]) >= minAlternateCount),]  
		}
		vcf <- do.call(rbind,unlist(allVcfs))
	} else {
		vcf <- vcf[info(vcf)$DP < maxDp & info(vcf)$DP > minDp,]
	}
	return(vcf)
}

##########
#INITIATE#
##########
library(VariantAnnotation)
library(reshape2)
library(ggplot2)
library(ggExtra)
library(scales)
library(RColorBrewer)
library(IRanges)
library(GenomicRanges)
library(Biostrings)
library(seqLogo)
library(gridExtra)
system(paste("mkdir -p",outdir))


#read
vcf            <- readVcf(vcfFile, "placeHolderFakeName")
refAssembly    <- readDNAStringSet(reference)
#patch vcf end position using the END field
if(useENDfield == "yes") {
        end(vcf) = info(vcf)$END
}
#1st filter round
vcf            <- filterVCF(vcf)
howmanyalleles <- elementNROWS(alt(vcf))

#select the chrs from chrSizes that are also in the vcf
chrSizes <- read.table(chrSizeFile,stringsAsFactors=F,header=F)
names(chrSizes)      <- c("chr","size")
class(chrSizes$chr)  <- "character"
class(chrSizes$size) <- "integer"
chrSizes <- chrSizes[chrSizes$chr %in% unique(seqnames(vcf)),]
chrs     <- chrSizes$chr

######################################################################################
#if you do not select just the SNVs with one single variant allele (--variant single)#
#different allele will be counted as a separate SNVs, with different AO and same RO  #
#i.e. the same position is counted as many times as the number of alternative alleles#
#there are. It works, but you double count multi allele loci                         #
######################################################################################
ROforEachAllele      <- rep(geno(vcf)[["RO"]],howmanyalleles)
RRforEachAllele      <- unlist(geno(vcf)[["AO"]]) / (unlist(geno(vcf)[["AO"]]) + ROforEachAllele)
AOforEachAllele      <- unlist(geno(vcf)[["AO"]])
CHRforEachAllele     <- rep(as.character(seqnames(vcf)),howmanyalleles)
startForEachAllele   <- rep(start(vcf),howmanyalleles)
depthForEachAllele   <- rep(info(vcf)$DP,howmanyalleles)
QaForEachAllele      <- unlist(info(vcf)$QA)
QrForEachAllele      <- rep(info(vcf)$QR ,howmanyalleles)
MQMforEachAllele     <- unlist(info(vcf)$MQM)
MQMRforEachAllele    <- rep(info(vcf)$MQMR,howmanyalleles)
ref_altForEachAllele <- paste( as.vector(rep(unlist(ref(vcf)),howmanyalleles))   , as.vector(unlist(alt(vcf))) ,sep="_")
df <- makeDf(CHRforEachAllele , startForEachAllele , RRforEachAllele , AOforEachAllele , rep(howmanyalleles,howmanyalleles) , depthForEachAllele , QaForEachAllele , QrForEachAllele , MQMforEachAllele , MQMRforEachAllele , ref_altForEachAllele)
#total allele variants per chr
varPerChr <- table(CHRforEachAllele) [match (chrs , names(table(CHRforEachAllele)))]
varPerChrNormalised <- normalise(varPerChr , chrSizes )
outName <- variants
plotAll(varPerChrNormalised , df , outName , chrSizes)




############
#single var#
############
#singAlt   <- vcf[howmanyalleles==1]
##ratio alternative/reference
#singAltRR <- unlist(geno(singAlt)[["AO"]])/(unlist(geno(singAlt)$AO) + unlist(geno(singAlt)$RO))
##read-ratio perChr
#singAltRRperCHR <- split(singAltRR, as.character(seqnames(singAlt)))
##tot var perChr
#varPerChr            <- sapply(singAltRRperCHR, length)
#varPerChr            <- varPerChr[ match(chrs , names(varPerChr)  ) ]
#varPerChrNormalised  <- normalise(varPerChr , chrSizes )
##df with all the info
#df <- makeDf(as.character(seqnames(singAlt)) , start(singAlt) , singAltRR , rep(1,length(singAltRR)))
#plotAll(varPerChrNormalised , df , "singleVariant")



