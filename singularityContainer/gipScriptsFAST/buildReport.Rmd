---
title: "`r sample` sample report"
subtitle: "GIP version `r version`" 
author: "Genome Instability Pipeline"
date: "`r format(Sys.time(), '%d %B, %Y')`"
sample: "`r sample`"
version: "`r version`"
output: 
  html_document: 
    keep_md: yes
    number_sections: yes
    smart: no
    toc: yes
    toc_float: yes
editor_options: 
  chunk_output_type: console
---

<!--  https://bookdown.org/yihui/bookdown/figures.html
https://yihui.org/knitr/options/
fig.align='right', fig.cap='caption'
 -->


```{r setup, cache = FALSE, echo=FALSE, include=FALSE}
library(knitr)
#library(png)
print(getwd())
knitr::opts_chunk$set(warning = FALSE, message = FALSE, cache.lazy = FALSE, cache = FALSE, echo=FALSE )
#knitr::opts_knit$set(root.dir = getwd())
#fig caption above
knit_hooks$set(plot = function(x, options) {
  paste('<figure><figcaption>', options$fig.cap, '</figcaption><img src="',
        opts_knit$get('base.url'), paste(x, collapse = '.'),
        '"></figure>',
        sep = '')
})
Sys.setenv("LANGUAGE"="EN")
tableX  <- 1
figureX <- 1
```

```{r logo, echo=FALSE , out.width = "50%"}
htmltools::img(src = knitr::image_uri("/bin/logo.jpg"),
               alt = 'logo',
               style = 'position:absolute; top:0; right:0; padding:10px; width: 320px; height: 160px')
```

```{r countRepeats}
repsDf <- read.table("repeats/genome.out.gff",stringsAsFactors=F,sep="\t")[,c(1,4,5)]
names(repsDf) <- c("chr","start","end")
repNt <- as.integer( sum((repsDf$end - repsDf$start) +1))
chrSize <- read.table("genome.chrSize",stringsAsFactors=F,col.names=c("chr","size"))
genomeSize <- sum(chrSize$size)
percRep <- round(repNt/genomeSize * 100,digit=2)
```

# Sample metrics
## Alignment summary
The provided genome measures `r genomeSize`nt, of which `r repNt`nt were predicted as simple or transposable repetitive elements (`r percRep`% of the genome).  
The genome sequence file with the repetitive positions lower-cased is available from [here](`r paste0("../genome/genome.fa")`).  
The genomic coordinates of the repetitive elements are available from [here](`r paste0("../genome/repeats/genome.out.gff")`).     
Sequencing reads were aligned to the provided genome using `BWA`[[1]](#references).  
**Table `r tableX`** reports the sequencing read alignment statistics computed with `Picard`[[2]](#references)  
See https://broadinstitute.github.io/picard/picard-metric-definitions.html#AlignmentSummaryMetrics for metrics definition
```{r alignmentSummary, cache = FALSE , echo=FALSE , results= 'asis'}
medianGenomeCov   <- read.table(paste0(sample,".covPerNt.medianGenomeCoverage"))$V1
mappingStatsDf    <- read.delim(paste0(sample,".alignmentMetrics.table"))
mappingStatsDf[,c("PF_READS","PCT_PF_READS","PF_NOISE_READS","PF_HQ_ALIGNED_READS", "PF_HQ_ALIGNED_BASES" ,"PF_HQ_ALIGNED_Q20_BASES" ,"PF_HQ_MEDIAN_MISMATCHES","PF_HQ_ERROR_RATE","BAD_CYCLES","SAMPLE","LIBRARY","READ_GROUP")]  <-list(NULL) 
kable(mappingStatsDf , align='c', caption=paste0("Table ",tableX,": Alignment statistics"))
tableX <- tableX + 1
```

## Read insert size
**Figure `r figureX`** demonstrates the insert size distributions for read pairs with Forward-Reverse (FR), Reverse-Forward (RF) and TANDEM orientation.  
The statistics relative to the pair-end insert size were computed with `Picard` and reported in **Table `r tableX`**    
See https://broadinstitute.github.io/picard/picard-metric-definitions.html#InsertSizeMetrics for metrics definition.  

```{r insertSizePng  , out.width = "100%", fig.cap=paste0("Figure ",figureX -1,": Insert size distribution")}
knitr::include_graphics(paste0(sample,".insertSize.hist.png"))
figureX <- figureX +1
```
```{r insertSizeTable, cache = FALSE , echo=FALSE , results= 'asis'}
insertSizeDf <- read.delim(paste0(sample,".insertSize.table"))
row.names(insertSizeDf) <- insertSizeDf$PAIR_ORIENTATION
insertSizeDf[,c("PAIR_ORIENTATION","SAMPLE","LIBRARY","READ_GROUP")]  <-list(NULL) 
kable(insertSizeDf , align='c' , "simple" , caption=paste0("Table ",tableX,": Insert size statistics"))
tableX <- tableX + 1
```


## Read duplicates
Duplicated reads (i.e. originating from a single fragment of DNA) were detected with `Picard`.  
 **Table `r tableX`** reports read duplicates statistics.  
See https://broadinstitute.github.io/picard/picard-metric-definitions.html#DuplicationMetrics for metrics definition
```{r markDupTable, cache = FALSE , echo=FALSE , results= 'asis'}
markDupDf <- read.delim(paste0(sample,".MarkDup.table"))
markDupDf[,c("LIBRARY")]  <-list(NULL) 
kable(markDupDf , align='c', "simple" , caption=paste0("Table ",tableX,": Read duplicates statistics"))
tableX <- tableX + 1
```

The saturation curve in **Figure `r figureX`** shows the return of interest (ROI) if additional sequencing data was produced from the same library.  
For sequencing at higher depth the estimated gains in library complexity (i.e. the number of unique molecules in the sequencing library) does not grow linearly since more and more of the reads are duplicates.  
The left most dot indicates the current ROI.  
See https://broadinstitute.github.io/picard/faq.html  for more info regarding the histogram produced by MarkDuplicates.  

```{r markDupPng  , out.width = "50%" , fig.cap=paste0("Figure ",figureX -1,": Return of investment for sequencing the library at higher coverage")}
knitr::include_graphics(paste0(sample,".MarkDup.hist.png"))
figureX <- figureX + 1
```


## Genome coverage
### Sequencing depth
The median genome sequencing coverage is **`r medianGenomeCov`**.    
**Table `r tableX`** reports the median sequencing coverage (MEDIANCOV) for individual chromosomes.  
MEDIANCOVminus2MAD and MEDIANCOVplus2MAD reflect the sequencing coverage variability, indicating the median sequencing coverage -/+ 2 mean absolute deviations respectively.
```{r covPerChr, cache = FALSE , echo=FALSE , results= 'asis'}
covPerChr <- read.table(paste0("chrCoverageMedians_",sample),header=T,stringsAsFactors=F)
kable(covPerChr , align='c', "simple" ,caption=paste0("Table ",tableX,": Chromosome coverage"))
tableX <- tableX + 1
```
  
### Somy score normalization
The distribution of nucleotide sequencing coverage was used to estimate chromosome copy number.  
To calculate the somy score, the sequencing coverage of each nucleotide was normalized by the median genome sequencing coverage and multiplied by two.  
**Figure `r figureX`** and **Figure `r figureX + 1`** are two alternative somy score distribution visualizations. 
  
  
```{r covPerNtBoxplot  , out.width = "50%" , fig.cap=paste0("Figure ",figureX -1,": Boxplot somy score distribution")}
knitr::include_graphics(paste0(sample,".covPerNt.boxplot.png"))
figureX <- figureX + 1
```
  
  
```{r covPerNtRidges  , out.width = "50%" , fig.cap=paste0("Figure ",figureX -1,": Density plot, somy score distributio")}
knitr::include_graphics(paste0(sample,".covPerNt.ridges.png"))
figureX <- figureX + 1
```
  
The genome sequencing coverage density is available in bigWig format from [here](`r paste0("../samples/",sample,"/",sample,".bw")`).  
BigWig file format is compatible with genome browsers such as `IGV`[[3]](#references).  
A description of the bigWig format is available from https://genome.ucsc.edu/goldenPath/help/bigWig.html  


# Genomic bins coverage
```{r covPerStats}
tmp <- read.table(paste0(sample,".covPerBin.gz"),header=T)[1,]
binSize <-  tmp$end - tmp$start + 1
tmp <- system(paste0("grep minMAPQ ",sample,".covPerBin.significant.stats"),intern=T)
minMAPQbin <- gsub(x=tmp,pattern=".*MAPQ (\\d+).*",replacement="\\1")
covPerBinSigPvalThresh <- gsub(x=tmp,pattern=".*threshold\\s+([\\d|\\.]+).*",replacement="\\1",perl=T)
numSigCovPerBin <- gsub(x=tmp,pattern=".*\\s+(\\d+).*$",replacement="\\1")
sigSegments <- read.table(paste0(sample,".covPerBin.significant.segments.tsv.gz"),header=T,stringsAsFactors=F)
sigAmpSegments <- sigSegments[sigSegments$direction == "amplification",]
sigDepSegments <- sigSegments[sigSegments$direction == "depletion",]
pickFromDf <- function(df,sortCol,n,side,colToRm){
  if(length(df[,1]) < n) {
    n <- length(df[,1])
  }
  if(! is.na(colToRm[1])){
   df[,colToRm] <- list(NULL)
  }
  if(is.na(side)){
    #do not sort 
  } else if(side=="head"){
    df <- df[ order(df[[sortCol]],decreasing=TRUE), ]
  } else if (side == "tail"){
    df <- df[ order(df[[sortCol]],decreasing=FALSE), ]
  }
  return(head(df,n=n))
}
displaySigAmpSegTab <- length(sigAmpSegments[,1]) > 0
displaySigDepSegTab <- length(sigDepSegments[,1]) > 0
```

The genome was divided in contiguous bins spanning `r binSize` nucleotides, and their coverage was evaluated by  

* measuring the sequencing coverage of each nucleotide  
* computing the mean bin coverage  
* normalizing by the median chromosome coverage   

The mean MAPQ score of the reads aligning to each bin was also computed.  
Genomic bins with mean MAPQ score > `r minMAPQbin` were evaluated to identify significantly amplified or depleted regions.  
Considering an adjusted p-value threshold of `r covPerBinSigPvalThresh` and considering possible user-defined additional coverage cut-offs, a total of `r numSigCovPerBin` genomic bins were deemed to be either significantly enriched or depleted.

```{r covPerBinAll  , out.width = "50%" , fig.cap=paste0("Figure ",figureX -1,": Genomic bin coverage overview")}
knitr::include_graphics(paste0(sample,".covPerBin.plot.all.png"))
figureX <- figureX +1
```


```{r covPerBinFaceting  , out.width = "100%" , fig.cap=paste0("Figure ",figureX -1,": Genomic bin coverage in separate chromosomes")}
knitr::include_graphics(paste0(sample,".covPerBin.plot.faceting.png"))
figureX <- figureX +1
```

Significant bins can be found [here](`r paste0("../samples/",sample,"/",sample,".covPerBin.significant.bins.tsv.gz")`)  
Collapsing significant adjacent bins into larger regions (*segments*) and averaging the bin coverage resulted in `r length(sigAmpSegments[,1])` amplified regions and `r length(sigDepSegments[,1])` depleted regions available from [here](`r paste0("../samples/",sample,"/",sample,".covPerBin.significant.segments.tsv.gz")`)  
  
<!-- Change echo=TRUE or FALSE to display/hide this chunk. -->
<!--
```{asis, echo=displaySigAmpSegTab}
Example of significantly amplified sements
```
-->

```{r, eval=displaySigAmpSegTab , include=displaySigAmpSegTab}
tmp <- pickFromDf(sigAmpSegments,"score",5,"head","direction")
kable(tmp , align='c', "simple", row.names = F , caption=paste0("Table ",tableX,": Example of significantly amplified segments"))
tableX <- tableX +1
```
```{r, eval=displaySigDepSegTab , include=displaySigDepSegTab}
tmp <- pickFromDf(sigDepSegments,"score",5,"tail","direction")
kable(tmp , align='c', "simple" , row.names = F , caption=paste0("Table ",tableX,": Example of significantly depleted segments"))
tableX <- tableX +1
```


# Gene coverage
```{r covPerGeStats }
tmp <- system(paste0("grep MAPQ ",sample,".covPerGe.significant.stats"),intern=T)
minMAPQge <- gsub(x=tmp,pattern=".+MAPQ > than  (\\d+).+",replacement="\\1")
covPerGePlotDf <- read.table(paste0(sample,".covPerGeKaryoplot/covPerGePlotData.tsv"),header=T,stringsAsFactors=F,sep="\t"  )
sigGeDf <- covPerGePlotDf[ covPerGePlotDf$status %in% c("amplified","depleted") , ]
sigAmpGe <- sigGeDf[sigGeDf$status == "amplified",]
sigDepGe <- sigGeDf[sigGeDf$status == "depleted",]
displaySigDepGeTab <- length(sigDepGe[,1]) > 0
displaySigAmpGeTab <- length(sigAmpGe[,1]) > 0
```
The gene sequencing coverage was evaluated by

* measuring the sequencing coverage of each nucleotide
* computing the mean gene coverage excluding N positions
* normalizing by the median chromosome coverage  

The MAPQ score of the reads aligning to each gene was also evaluated.
Genes with mean MAPQ score > `r minMAPQge` were evaluated to identify significantly amplified or depleted genes.
A total of `r length(sigAmpGe[,1])` genes resulted significantly amplified, and a total of `r length(sigDepGe[,1])` significantly depleted  

```{r covPerGePlot1  ,  results= 'asis' }
chrsWithSigGe <- unique(gsub(x=sigGeDf$locus,pattern=":.+",replacement=""))
chrsFilesWithSigGe <- paste0(sample,".covPerGeKaryoplot/",chrsWithSigGe,".png")
displayCovPerGeCap <- FALSE
if(length(chrsFilesWithSigGe) > 0 ){
 displayCovPerGeCap=TRUE
 cat(paste0("Figure ",figureX,": Overview of chromosomes embedding significant copy number variant genes"))
 figureX <- figureX +1
}
```

```{r covPerGePlot2  , out.width = "100%" ,  results= 'asis' , eval=displayCovPerGeCap , include=displayCovPerGeCap}
knitr::include_graphics(chrsFilesWithSigGe)
```

```{r, eval=displaySigAmpGeTab , include=displaySigAmpGeTab}
tmp <- pickFromDf(sigAmpGe,"normalizedMeanCoverage",5,"head",c("status","color"))
kable(tmp , align='c', "simple" , row.names = F , caption=paste0("Table ",tableX,": Example of significantly amplified genes"))
tableX <- tableX +1
```
```{r, eval=displaySigDepGeTab , include=displaySigDepGeTab}
tmp <- pickFromDf(sigDepGe,"normalizedMeanCoverage",5,"tail",c("status","color"))
kable(tmp , align='c', "simple" , row.names = F , caption=paste0("Table ",tableX,": Example of significantly depleted genes"))
tableX <- tableX +1
```

The table with the sequencing coverage of significantly amplified, depleted or non-varying genes can be found [here](`r paste0("../samples/",sample,"/",sample,".covPerGeKaryoplot/covPerGePlotData.tsv")`).


# Single nucleotide variants
Single nucleotide variant (SNV) analysis include

* predicting the SNVs with `freebayes`[[4]](#references)
* applying custom quality filters limiting the number of predictions to a number of high quality predictions
* predicting the SNV effect with `snpEff`[[5]](#references)
* computing the dN/dS ratio

```{r dNdSstats ,  results='asis'}
dndsStats <- system(paste0("cat ",sample,"_freebayesFiltered/dNdS.stats"),intern=T)
dndsStatDf <- data.frame(metric=gsub(x=dndsStats,pattern="(.+)\\s+(\\S+)$",replacement="\\1") , count=gsub(x=dndsStats,pattern="(.+)\\s+(\\S+)$",replacement="\\2") , stringsAsFactors=F)
dndsStatDf$metric <- gsub(x=dndsStatDf$metric,pattern="^the number of ",replacement="")
dndsStatDf$metric <- gsub(x=dndsStatDf$metric,pattern="the mean number of SNVs per gene is ",replacement="mean number of SNVs per gene")
kable(dndsStatDf , align='c', "simple" , row.names = F , caption=paste0("Table ",tableX,": SNV statistics"))
tableX <- tableX +1
```

```{r snvStats ,  results='asis'}
snvDf <- read.delim(paste0(sample,"_freebayesFiltered/singleVariants.df.gz") ,sep="\t",stringsAsFactors=F,header=T)
snvDf$EFFclean <- gsub(x=snvDf$EFF,pattern="^(.+)\\(.*",replacement="\\1")
snvDf$SYN <- 1
synNames=c("SYNONYMOUS_CODING","SYNONYMOUS_STOP")
nonSynNames=c("NON_SYNONYMOUS_CODING","NON_SYNONYMOUS_START","START_LOST","STOP_GAINED","STOP_LOST")
snvDf[ snvDf$EFFclean %in% nonSynNames , "SYN"] = 2
snvDf <- snvDf[with(snvDf, order(-SYN , -freq , -AO)), ]
displaySnvEx <- FALSE
if(length(snvDf[,1]) > 0){
 displaySnvEx=TRUE
}
dndsDf <- read.delim(paste0("./",sample,"_freebayesFiltered/dNdStable.tsv.gz"),stringsAsFactors=F,header=T,sep="\t")
displayDnDsEx <- FALSE
if(length(dndsDf[,1]) > 0){
 displayDnDsEx=TRUE
}
```
  
```{r snvExample ,  results='asis' , eval=displaySnvEx ,  include=displaySnvEx}
tmp <- pickFromDf(snvDf,"none",5,NA,c("alt","EFFclean","SYN","QA","QR","MQM","MQMR"))
kable(tmp , align='c', "simple" , row.names = F , caption=paste0("Table ",tableX,": SNVs examples"))
tableX <- tableX +1
```
  
The full set of SNVs predictions in VCF format is available from [here](`r paste0("../samples/",sample,"/",sample,".vcf.gz")`).
The filtered set of SNVs predictions in VCF format is available from [here](`r paste0("../samples/",sample,"/",sample,"_freebayesFiltered/singleVariants.vcf.gz")`).  
A tabulated version of the filtered set is available from [here](`r paste0("../samples/",sample,"/",sample,"_freebayesFiltered/singleVariants.df.gz")`).  
  
```{r dndsExample ,  results='asis' , eval=displayDnDsEx ,  include=displayDnDsEx}
tmp <- pickFromDf(dndsDf,"difference",5,"head",NA)
kable(tmp , align='c', "simple" , row.names = F , caption=paste0("Table ",tableX,": dNdS comparison examples"))
tableX <- tableX +1
```
  
The table including the dNdS analysis of the filtered set is available from [here](`r paste0("../samples/",sample,"/",sample,"_freebayesFiltered/dNdStable.tsv.gz")`).  
  
   
```{r SNVplots1  , out.width = "100%" , fig.cap=paste0("Figure ",figureX -1,": SNV density")}
knitr::include_graphics(paste0(sample,"_freebayesFiltered/single_allDensities.png"))
figureX <- figureX +1
```
```{r SNVplots2  , out.width = "100%" , fig.cap=paste0("Figure ",figureX -1,": SNV scatterplot")}
knitr::include_graphics(paste0(sample,"_freebayesFiltered/single_VRFvsPosFaceting.png"))
figureX <- figureX +1
```
```{r SNVplots3  , out.width = "100%" , fig.cap=paste0("Figure ",figureX -1,": SNV depth vs SNV frequency")}
knitr::include_graphics(paste0(sample,"_freebayesFiltered/single_depthVsVRFletters.png"))
figureX <- figureX +1
```
```{r SNVplots4  , out.width = "100%" , fig.cap=paste0("Figure ",figureX -1,": variant types")}
knitr::include_graphics(paste0(sample,"_freebayesFiltered/single_variantTypeCombined.png"))
figureX <- figureX +1
```



# Structural variants
`delly`[[6]](#references) was used to detect structural variants (SVs) based of read pairing orientation and split reads information.  
The genomic SVs that were evaluated include 

* inversions
* translocations
* duplications
* deletions 

The file in VCF format with delly's predictions is available from [here](`r paste0("../samples/",sample,"/",sample,".delly.vcf.gz")`).  
Downstream filters were applied on the delly's output to reduce the number of false positives.  
The filtered output is available from [here](`r paste0("../samples/",sample,"/",sample,"_freebayesFiltered/dNdStable.tsv.gz")`).  

```{r dellyStats ,  results='asis'}
invDf <- read.delim(paste0(sample,"_dellyFiltered/",sample,".delly.INV.filter"),stringsAsFactors=F,header=T,sep="\t")
delDf <- read.delim(paste0(sample,"_dellyFiltered/",sample,".delly.DEL.filter"),stringsAsFactors=F,header=T,sep="\t")
dupDf <- read.delim(paste0(sample,"_dellyFiltered/",sample,".delly.DUP.filter"),stringsAsFactors=F,header=T,sep="\t")
traDf <- read.delim(paste0(sample,"_dellyFiltered/",sample,".delly.TRA.filter"),stringsAsFactors=F,header=T,sep="\t")
displayInv=FALSE ; if(length(invDf[,1])) {displayInv=TRUE;} 
displayDel=FALSE ; if(length(delDf[,1])) {displayDel=TRUE;} 
displayDup=FALSE ; if(length(dupDf[,1])) {displayDup=TRUE;} 
displayTra=FALSE ; if(length(traDf[,1])) {displayTra=TRUE;} 
```
  
  
```{r dellySVs  , out.width = "50%" , fig.cap=paste0("Figure ",figureX -1,": Structural varaints analysis")}
knitr::include_graphics(paste0(sample,"_dellyFiltered/",sample,".SV.circos.png"))
figureX <- figureX +1
```
  
  
```{r inv ,  results='asis' , eval=displayInv ,  include=displayInv}
tmp <- pickFromDf(invDf,"percReadsSupportingSV",length(invDf[,1]),"head",c("rawSampleId"))
kable(tmp , align='c', "simple" , row.names = F , caption=paste0("Table ",tableX,": Genomic inversions"))
tableX <- tableX +1
```
  
```{r dup ,  results='asis' , eval=displayDup ,  include=displayDup}
tmp <- pickFromDf(dupDf,"percReadsSupportingSV",length(dupDf[,1]),"head",c("rawSampleId"))
kable(tmp , align='c', "simple" , row.names = F , caption=paste0("Table ",tableX,": Genomic duplications"))
tableX <- tableX +1
```
  
```{r del ,  results='asis' , eval=displayDel ,  include=displayDel}
tmp <- pickFromDf(delDf,"percReadsSupportingSV",length(delDf[,1]),"head",c("rawSampleId"))
kable(tmp , align='c', "simple" row.names = F , caption=paste0("Table ",tableX,": Genomic deletions"))
tableX <- tableX +1
```
  
```{r tra ,  results='asis' , eval=displayTra ,  include=displayTra}
tmp <- pickFromDf(traDf,"percReadsSupportingSV",length(traDf[,1]),"head",c("rawSampleId"))
kable(tmp , align='c', "simple" , row.names = F , caption=paste0("Table ",tableX,": Genomic translocations"))
tableX <- tableX +1
```
    
  
  
# References

**[1]** Li H, Durbin R. Fast and accurate short read alignment with Burrows-Wheeler transform. Bioinformatics. 2009 Jul 15;25(14):1754-60. doi:10.1093/bioinformatics/btp324. Epub 2009 May 18. PMID: 19451168; PMCID: PMC2705234.  
**[2]** "Picard Toolkit". Broad Institute, http://broadinstitute.github.io/picard.  
**[3]** Robinson JT, Thorvaldsdóttir H, Winckler W, Guttman M, Lander ES, Getz G,Mesirov JP. Integrative genomics viewer. Nat Biotechnol. 2011 Jan;29(1):24-6. doi: 10.1038/nbt.1754. PMID: 21221095; PMCID: PMC3346182.  
**[4]** Garrison E, Marth G. Haplotype-based variant detection from short-read sequencing. arXiv preprint arXiv:1207.3907 [q-bio.GN] 2012  
**[5]** "A program for annotating and predicting the effects of single nucleotide polymorphisms, SnpEff: SNPs in the genome of Drosophila melanogaster strain w1118; iso-2; iso-3.", Cingolani P, Platts A, Wang le L, Coon M, Nguyen T, Wang L, Land SJ, Lu X, Ruden DM. Fly (Austin). 2012 Apr-Jun;6(2):80-92. PMID: 22728672  
**[6]** Rausch T, Zichner T, Schlattl A, Stütz AM, Benes V, Korbel JO. DELLY:structural variant discovery by integrated paired-end and split-read analysis. Bioinformatics. 2012 Sep 15;28(18):i333-i339. doi:10.1093/bioinformatics/bts378. PMID: 22962449; PMCID: PMC3436805.  

L-GERT github page: 
https://github.com/giovannibussotti/L-GERT

<div class="fold o">
```{r}
sessionInfo()
```
</div>
